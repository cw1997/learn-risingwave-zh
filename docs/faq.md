---
sidebar_position: 2
---

# 有意思的问题

当第一次接触 RisingWave 或者流数据库时，不同背景的读者往往会问出很多有意思的问题。在本文中，我们总结了一下常见的问题。

## RisingWave 是否可以平替 Flink SQL？

RisingWave 本身能力是 Flink SQL的超集。从能力角度来讲，Flink SQL 的用户完全可以较为容易的迁移到 RisingWave 上。但要注意的是，RisingWave 与 Flink SQL 在语法上仍然有一些细微差别，因此用户还是可能需要对部分查询进行改写。

当然，RisingWave 使用的是 PostgreSQL 语法，相信学习与使用门槛要远低于 Flink SQL。


## RisingWave 是否是流批一体系统？

“流批一体”这个名词最早是用来描述 Apache Spark、Apache Flink 这样的计算平台，而非数据库。但如果我们将这个概念对应到数据库中，那么流处理就是对新插入的数据进行连续不断的增量计算，而批处理就是对已经存储的数据进行随机批量计算。RisingWave 很显然能够同时支持流处理与批处理。

需要注意的是，RisingWave 的强项是流处理。在存储格式方面，由于 RisingWave 采用的是行存，因此 RisingWave 更加适合对已存储的数据做点查，而并非全表扫描。因此，如果用户对随机全表分析查询有大量需求，那么我们更加推荐用户使用 ClickHouse、Apache Doris 等实时分析型数据库。

## RisingWave 支持事务处理吗？

RisingWave 不支持读写事务处理，但其支持只读事务。RisingWave 并不能替代 PostgreSQL 做事务处理。这一设计主要是因为在真实场景中，用户一般都需要使用独占的事务型数据库以支持在线业务。如果在同一数据库内同时支持事务处理与流处理，将使得数据库的负载处理变得极为复杂，很难达到两方面最优。

在生产中，使用 RisingWave 的最佳实践是将 RisingWave 放在事务型数据库的下游。RisingWave 通过 CDC 从事务型数据库中读取已经被序列化过的数据。


## RisingWave 中的表存储为什么使用行存？

RisingWave 使用了相同的存储系统来支持内部状态管理与数据存储。在内部状态管理中，各类算子的存储均更适合使用行存，而在数据存储中，由于用户更有可能偏向于进行随机点查，因此也是使用行存更加合适。未来 RisingWave 有可能会周期性将行存转换成列存，以更好的支持随机分析类查询。


## 流数据库是否可以被认为是流处理引擎+数据库组合？

从功能上来讲，开发者的确可以使用流处理引擎（如 Apache Flink）与数据库（如 PostgreSQL）进行拼接组合来模拟出流数据库。但是这种拼接组合在实践过程中可能会遇到巨大问题。

* 从设计来讲，流数据库使用同一套存储进行内部状态管理与结果存储与结果随机查询。独立的数据库很显然不适合做内部状态存储，因为频繁跨系统数据访问会造成巨大开销，对流处理系统这类对延迟敏感的系统来说并不可取。事实上，早年的分布式流处理引擎，如 Apache Storm、Apache S4 等，均试过这条道路，但这种设计并没有成功延续下来；
* 从运维来讲，很显然运维两套不同的系统会带来非常高的运维成本；
* 从实现来讲，想要在两个独立系统之间保证一致性，则需要建立一套框架保证即便在某一系统宕机之后，两个系统之间仍能够做到一致。实现这一框架显然需要付出更多的工程投入；
* 从用户体验来讲，用户使用两套系统的体验与使用一套系统的体验有相当大的差距。


## 流数据库与实时分析数据库中的物化视图有什么不同？

流数据库中的物化视图与实时分析数据库的物化视图看似相同，但实际差别巨大。
在如 RisingWave 等为代表的流数据库中，物化视图呈现的是流处理之后得到的一致的、新鲜的计算结果，而在如 ClickHouse 等为代表的实时分析数据库中，物化视图主要作用是为了加速查询。
