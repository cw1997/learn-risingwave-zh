---
sidebar_position: 1
---

# 快速入门

本文的目的是让大家能够在 **10分钟之内** 了解 RisingWave 流数据库是什么。

:::danger 注意1

本教程并非正式官方教程，并且不保证与官方文档内容同步（本教程写作时基于2023年9月发布的 RisingWave 1.2.0版本）。本教程的目的仅是让大家快速学习 RisingWave 流数据库。具体内容还请读者以[**官方文档**](https://docs.risingwave.com/)为准。
:::

:::danger 注意2
本教程仍在持续开发中。最新更新日期为：
**2023年10月15日**。
欢迎对 RisingWave、流处理、数据库或是数据工程感兴趣的朋友们提出宝贵的建议！
:::

## 什么是 RisingWave

RisingWave 是一款流数据库。简单来说，流数据库就是让用户可以用使用数据库的方式来处理流数据，进行连续不断的实时流计算，并提供数据存储与随机查询的功能。

RisingWave 是一款开源（Apache 2.0 协议）分布式流数据库。其与 PostgreSQL 传输协议兼容，也就是说，用户可以像使用 PostgreSQL 一样使用 RisingWave。

**用户可以使用 RisingWave 来进行**：

- 流计算；
- 数据存储；
- 随机查询（尤其是点查）。

**用户不应该使用 RisingWave 来进行**：

- 事务处理；
- 频繁的涉及到全表扫描的复杂查询。

也就是说，**用户可以使用 RisingWave 来替换**：

- 如 Apache Flink、Apache Spark Streaming、KsqlDB 等系统来进行流处理；
- 如 Apache Flink + Cassandra / Redis / DynamoDB 这样的系统组合。

**而不应该使用 RisingWave 替换**：

- 如 PostgreSQL、MySQL、TiDB 等系统来进行事务处理；
- 如 ClickHouse、Apache Doris 等系统来进行复杂分析查询；
- 如 ElasticSearch 等系统来进行全文搜索。

## RisingWave 解决的流处理痛点

市面上已经有了一些知名的开源流处理系统，如 Apache Flink、Apache Spark Streaming、KsqlDB 等。那为什么我们需要使用 RisingWave？

对比于其他流处理系统，RisingWave 主要聚焦在两大方面：**易用性**与**成本效率**。简单来说：

- RisingWave 为用户带来了 PostgreSQL 般的体验来进行流处理，大幅降低使用流计算技术的门槛；
- RisingWave 实现了类似于 Snowflake 的存算分离架构，从而实现计算与存储成本的大幅降低。

从用户角度来讲，RisingWave 解决了以下几个常见的流处理系统痛点：

### 学习曲线陡峭

现有流处理系统几乎都有很陡峭的学习曲线，不光入门难，在入门之后学习核心概念、使用进阶功能也很难。不少用户在入坑流处理系统之后，被各种底层概念搞得晕头转向，很难掌握各种进阶技巧，如 window、watermark、join 等等，很难真正用好流计算。

:::tip RisingWave 解决方式
RisingWave 提供与 PostgreSQL 兼容的 SQL 接口，并通过 Python、Java 等语言的 UDF 来提升整体表达能力。更重要的是，RisingWave 对底层细节进行了高层封装，让用户无需感知底层实现。
:::

### 多流 join 低效

不少流处理系统都提供了 SQL 接口，用户直接使用 SQL 中的 join 算子来进行多流 join。而由于内部状态管理问题与实现问题，这些流处理系统的 join 算子稳定性差、性能差，只要处理5-10 个流的 join，要么效率低下，要么直接系统挂掉，更不用说处理更多流的 join。

:::tip RisingWave 解决方式
RisingWave 在多流 join 场景下做了大量优化，尤其是在状态管理方面使用了更精细的管理模式，使系统在进行多流 join 时保持高效与稳定。在生产场景下，RisingWave 能够很好的处理 10-20 个（甚至更多）流的 join。
:::

### 资源使用率低

多数现有流处理系统诞生于大数据时代，使用类 MapReduce 架构暴力使用资源来进行流计算。在这些系统上，每个任务（job）完全独立，无法共享资源。而用户需要对每个任务进行资源分配，很容易出现资源分配过多导致浪费的情况。更重要的是，流计算对资源的使用会根据负载变化而变化，由于这些系统并不支持高效动态扩缩容，导致真实生产环境下，用户往往按照负载峰值来分配资源，进一步导致资源使用率低下。

:::tip RisingWave 解决方式

RisingWave 本质是数据库。在数据库中，不同（连续）查询共享资源。用户无需对资源使用进行干预。同时，RisingWave 采用存算分离架构，能够轻松实现动态扩缩容。
:::

### 大状态管理难

在进行复杂流计算，如 window、join 等时，不少系统会出现性能暴跌甚至崩溃的情况。这是因为在这些系统中，状态保存在本地计算实例，只要状态过大，则会导致性能与稳定性问题。

:::tip RisingWave 解决方式

RisingWave 采用的存算分离架构使计算状态永远持久化远端，而非本地。这使得 RisingWave 用户无需担心内部状态大小问题。为了实现性能最优，RisingWave 只在本地实例中做状态缓存。
:::

### 动态扩缩容难

在多数现有流处理中，动态扩缩容支持很弱。究其原因，主要是因为这些系统都采用了存算耦合的架构：内部状态存储与计算高度绑定。这导致了其无法平滑实现动态扩缩容。

:::tip RisingWave 解决方式

RisingWave 采用了存算分离架构，使用远端对象存储持久化计算内部状态，而计算并不绑定内部状态。这使得动态扩缩容基本可以在秒级完成。
:::

### 故障恢复慢

流计算系统定期保存检查点（checkpoints）。当故障发生时，系统只需要从最近的检查点开始重新进行计算。重算时间，也就是系统恢复时间，与检查点间隔正相关。多数现有流处理系统的检查点间隔在1分钟以上，而在实际生产环境上，不少将检查点配置在3分钟、5分钟、甚至10分钟（以上）。这是因为这些系统的检查点间隔会影响性能：检查点间隔过小会导致性能大幅下降。当检查点间隔过大时，便会导致当系统故障时，需要较长的恢复时间。而这种长时间的系统无可用在不少对延迟敏感的应用，如金融交易、监控、报警等，来说无法接受。

:::tip RisingWave 解决方式

RisingWave 的内部状态管理方式使得 RisingWave 检查点频率与性能解耦。这也就意味着用户可以将检查点间隔设置的非常小，保证服务宕机时间最小化。默认情况下，RisingWave 的检查点间隔为10秒。
:::

### 结果验证困难

目前常用的流处理系统不带存储。也就是说，流计算发生在流处理系统内部，而计算结果需要被导出到其他系统中。也就是说，如果用户进行流计算，那么数据输入在外部系统，数据输出也在外部系统，只有计算是在流处理系统进行的。可想而知结果验证非常不方便。更重要的是，现有流处理系统每个任务（job）独立运行，无法直接创建任务消费其他任务的结果。这导致每个任务的逻辑可能会非常复杂，难以调试，也难以验证正确性。

:::tip RisingWave 解决方式

RisingWave 是流数据库，自带存储。流计算结果以物化视图形式持久化下来。也就是说，计算过程与计算结果均在 RisingWave 内部。这使得用户可以轻易验证程序正确性。另外，用户可以在物化视图上叠加构建物化视图，也就是说，用户可以将复杂流计算程序拆解成多个物化视图，让程序编写与结果验证变得非常简单。
:::


### 结果服务架构复杂

由于现有的流处理系统不带存储，用户需要将结果导出到外部系统中去，并在外部系统，如 Cassandra / Redis / PostgreSQL 等，做结果服务（即支持用户高并发查询）。这就意味着用户需要运维两套系统。更困难的是，为了保证结果正确性，用户自己必须考虑如何解决跨系统间的数据一致性问题，带来了不必要的麻烦。

:::tip RisingWave 解决方式

RisingWave 是流数据库，不仅可以存储数据（包括输入数据与计算结果），同时可以支持用户对结果进行高并发访问。用户无需维护两套系统，也无需考虑数据一致性问题。用户永远可以在 RisingWave 看到一致的、新鲜的结果。

:::


### 系统运维难

现有的流处理系统将底层细节暴露给用户，让用户自己配置资源、调节并行度、调节内部状态参数等等。尽管对于高阶用户来说，暴露细节可以调出更好的性能，但是对于多数普通用户来说，暴露这些细节造成了不必要的学习成本，并且可能由于调节失误造成系统效率低下甚至崩溃。

:::tip RisingWave 解决方式

RisingWave 对用户屏蔽不必要的底层细节。用户只需要关注 SQL 代码层面的问题即可。
:::


## RisingWave 的不足

相比于 Apache Flink、Apache Spark Streaming 等流处理系统，RisingWave **不支持 Java、Python 等可编程接口**。不少 Apache Flink、Apache Spark Streaming 的资深用户选择使用了 Java、Python 等接口来进行编程。如果已有代码逻辑过于复杂、无法使用 SQL 改写，那么可能就不适合使用 RisingWave。当然，RisingWave 支持 Python / Java 等语言的 UDF。因此，如果你的程序可以使用 UDF 来表示，那么还是可以选用 RisingWave 的。

尽管与 PostgreSQL 协议兼容，但 RisingWave 并**不支持事务处理**，因此不能在事务处理应用中平替 PostgreSQL。不少用户将 MySQL、PostgreSQL 等 OLTP 数据库与 RisingWave 组合使用：他们使用 OLTP 数据库做事务处理，然后使用 RisingWave 消费数据库的 CDC，在 RisingWave 内部做流计算。

RisingWave 底层存储为行存，适合支持高并发点查。但是，RisingWave **不适合做分析型随机查询**。为支持分析型随机查询，用户还需将数据导入到实时分析数据库中进行操作。不少用户将 RisingWave 与 ClickHouse、Apache Doris 等实时分析数据库组合使用：他们使用 RisingWave 做流计算，同时使用实时分析数据库进行分析型随机查询。


## RisingWave 使用场景

RisingWave 的主要使用场景包括了监控、报警、实时动态报表、流式 ETL、机器学习特征工程等。其已经运用到金融交易、制造业、新媒体、物流等领域。
